#!/usr/local/Cellar/python@2/2.7.15_1/bin/python
# -*- mode: python; coding: utf-8 -*-
# 
# Mandos server - give out binary blobs to connecting clients.
# 
# 
# Everything else is
# Copyright © 2008-2015 Teddy Hogeborn
# Copyright © 2008-2015 Björn Påhlsson
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
# 
# Contact the authors at <mandos@recompile.se>.
# 

from __future__ import (division, absolute_import, print_function,
                        unicode_literals)

from future_builtins import *
from pprint import pprint

try:
    import SocketServer as socketserver
except ImportError:
    import socketserver
import socket
import argparse
import datetime
import errno
try:
    import ConfigParser as configparser
except ImportError:
    import configparser
import sys
import re
import os
import signal
import subprocess
import atexit
import stat
import logging
import logging.handlers
import pwd
import contextlib
import struct
import fcntl
import functools
try:
    import cPickle as pickle
except ImportError:
    import pickle
import multiprocessing
import types
import binascii
import tempfile
import itertools
import collections
import codecs

try:
    import gobject
except ImportError:
    from gi.repository import GObject as gobject

from zeroconf import Error, ServiceInfo, Zeroconf

import ctypes
import ctypes.util
import xml.dom.minidom
import inspect

try:
    SO_BINDTODEVICE = socket.SO_BINDTODEVICE
except AttributeError:
    try:
        from IN import SO_BINDTODEVICE
    except ImportError:
        SO_BINDTODEVICE = None

if sys.version_info.major == 2:
    str = unicode

version = "1.7.20"
stored_state_file = "clients.pickle"

logger = logging.getLogger()
syslogger = None

try:
    if_nametoindex = ctypes.cdll.LoadLibrary(
        ctypes.util.find_library("c")).if_nametoindex
except (OSError, AttributeError):
    
    def if_nametoindex(interface):
        "Get an interface index the hard way, i.e. using fcntl()"
        SIOCGIFINDEX = 0x8933  # From /usr/include/linux/sockios.h
        with contextlib.closing(socket.socket()) as s:
            ifreq = fcntl.ioctl(s, SIOCGIFINDEX,
                                struct.pack(b"16s16x", interface))
        interface_index = struct.unpack("I", ifreq[16:20])[0]
        return interface_index


def initlogger(debug, level=logging.WARNING):
    """init logger and add loglevel"""
    
    global syslogger
    syslogger = (logging.handlers.SysLogHandler(
        facility = logging.handlers.SysLogHandler.LOG_DAEMON,
        address = "/var/run/syslog"))
    syslogger.setFormatter(logging.Formatter
                           ('Mandos [%(process)d]: %(levelname)s:'
                            ' %(message)s'))
    logger.addHandler(syslogger)
    
    if debug:
        console = logging.StreamHandler()
        console.setFormatter(logging.Formatter('%(asctime)s %(name)s'
                                               ' [%(process)d]:'
                                               ' %(levelname)s:'
                                               ' %(message)s'))
        logger.addHandler(console)
    logger.setLevel(level)


class PGPError(Exception):
    """Exception if encryption/decryption fails"""
    pass


class PGPEngine(object):
    """A simple class for OpenPGP symmetric encryption & decryption"""

    def __init__(self):
        self.tempdir = tempfile.mkdtemp(prefix="mandos-")
        self.gpg = "gpg"
        try:
            output = subprocess.check_output(["gpgconf"])
            for line in output.splitlines():
                name, text, path = line.split(b":")
                if name == "gpg":
                    self.gpg = path
                    break
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise
        self.gnupgargs = ['--batch',
                          '--homedir', self.tempdir,
                          '--force-mdc',
                          '--quiet']
        # Only GPG version 1 has the --no-use-agent option.
        if self.gpg == "gpg" or self.gpg.endswith("/gpg"):
            self.gnupgargs.append("--no-use-agent")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._cleanup()
        return False

    def __del__(self):
        self._cleanup()

    def _cleanup(self):
        if self.tempdir is not None:
            # Delete contents of tempdir
            for root, dirs, files in os.walk(self.tempdir,
                                             topdown=False):
                for filename in files:
                    os.remove(os.path.join(root, filename))
                for dirname in dirs:
                    os.rmdir(os.path.join(root, dirname))
            # Remove tempdir
            os.rmdir(self.tempdir)
            self.tempdir = None

    def password_encode(self, password):
        # Passphrase can not be empty and can not contain newlines or
        # NUL bytes.  So we prefix it and hex encode it.
        encoded = b"mandos" + binascii.hexlify(password)
        if len(encoded) > 2048:
            # GnuPG can't handle long passwords, so encode differently
            encoded = (b"mandos" + password.replace(b"\\", b"\\\\")
                       .replace(b"\n", b"\\n")
                       .replace(b"\0", b"\\x00"))
        return encoded

    def encrypt(self, data, password):
        passphrase = self.password_encode(password)
        with tempfile.NamedTemporaryFile(
                dir=self.tempdir) as passfile:
            passfile.write(passphrase)
            passfile.flush()
            proc = subprocess.Popen([self.gpg, '--symmetric',
                                     '--passphrase-file',
                                     passfile.name]
                                    + self.gnupgargs,
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            ciphertext, err = proc.communicate(input=data)
        if proc.returncode != 0:
            raise PGPError(err)
        return ciphertext

    def decrypt(self, data, password):
        passphrase = self.password_encode(password)
        with tempfile.NamedTemporaryFile(
                dir=self.tempdir) as passfile:
            passfile.write(passphrase)
            passfile.flush()
            proc = subprocess.Popen([self.gpg, '--decrypt',
                                     '--passphrase-file',
                                     passfile.name]
                                    + self.gnupgargs,
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            decrypted_plaintext, err = proc.communicate(input=data)
        if proc.returncode != 0:
            raise PGPError(err)
        return decrypted_plaintext

# Pretend that we have a GnuTLS module
class GnuTLS(object):
    """This isn't so much a class as it is a module-like namespace.
    It is instantiated once, and simulates having a GnuTLS module."""

    library = ctypes.util.find_library("gnutls")
    if library is None:
        library = ctypes.util.find_library("gnutls-deb0")
    _library = ctypes.cdll.LoadLibrary(library)
    del library
    _need_version = b"3.3.0"

    def __init__(self):
        # Need to use "self" here, since this method is called before
        # the assignment to the "gnutls" global variable happens.
        if self.check_version(self._need_version) is None:
            raise self.Error("Needs GnuTLS {} or later"
                             .format(self._need_version))

    # Unless otherwise indicated, the constants and types below are
    # all from the gnutls/gnutls.h C header file.

    # Constants
    E_SUCCESS = 0
    E_INTERRUPTED = -52
    E_AGAIN = -28
    CRT_OPENPGP = 2
    CLIENT = 2
    SHUT_RDWR = 0
    CRD_CERTIFICATE = 1
    E_NO_CERTIFICATE_FOUND = -49
    OPENPGP_FMT_RAW = 0         # gnutls/openpgp.h

    # Types
    class session_int(ctypes.Structure):
        _fields_ = []
    session_t = ctypes.POINTER(session_int)

    class certificate_credentials_st(ctypes.Structure):
        _fields_ = []
    certificate_credentials_t = ctypes.POINTER(
        certificate_credentials_st)
    certificate_type_t = ctypes.c_int

    class datum_t(ctypes.Structure):
        _fields_ = [('data', ctypes.POINTER(ctypes.c_ubyte)),
                    ('size', ctypes.c_uint)]

    class openpgp_crt_int(ctypes.Structure):
        _fields_ = []
    openpgp_crt_t = ctypes.POINTER(openpgp_crt_int)
    openpgp_crt_fmt_t = ctypes.c_int  # gnutls/openpgp.h
    log_func = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_char_p)
    credentials_type_t = ctypes.c_int
    transport_ptr_t = ctypes.c_void_p
    close_request_t = ctypes.c_int

    # Exceptions
    class Error(Exception):
        # We need to use the class name "GnuTLS" here, since this
        # exception might be raised from within GnuTLS.__init__,
        # which is called before the assignment to the "gnutls"
        # global variable has happened.
        def __init__(self, message=None, code=None, args=()):
            # Default usage is by a message string, but if a return
            # code is passed, convert it to a string with
            # gnutls.strerror()
            self.code = code
            if message is None and code is not None:
                message = GnuTLS.strerror(code)
            return super(GnuTLS.Error, self).__init__(
                message, *args)

    class CertificateSecurityError(Error):
        pass

    # Classes
    class Credentials(object):
        def __init__(self):
            self._c_object = gnutls.certificate_credentials_t()
            gnutls.certificate_allocate_credentials(
                ctypes.byref(self._c_object))
            self.type = gnutls.CRD_CERTIFICATE

        def __del__(self):
            gnutls.certificate_free_credentials(self._c_object)

    class ClientSession(object):
        def __init__(self, socket, credentials=None):
            self._c_object = gnutls.session_t()
            gnutls.init(ctypes.byref(self._c_object), gnutls.CLIENT)
            gnutls.set_default_priority(self._c_object)
            gnutls.transport_set_ptr(self._c_object, socket.fileno())
            gnutls.handshake_set_private_extensions(self._c_object,
                                                    True)
            self.socket = socket
            if credentials is None:
                credentials = gnutls.Credentials()
            gnutls.credentials_set(self._c_object, credentials.type,
                                   ctypes.cast(credentials._c_object,
                                               ctypes.c_void_p))
            self.credentials = credentials

        def __del__(self):
            gnutls.deinit(self._c_object)

        def handshake(self):
            return gnutls.handshake(self._c_object)

        def send(self, data):
            data = bytes(data)
            data_len = len(data)
            while data_len > 0:
                data_len -= gnutls.record_send(self._c_object,
                                               data[-data_len:],
                                               data_len)

        def bye(self):
            return gnutls.bye(self._c_object, gnutls.SHUT_RDWR)

    # Error handling functions
    def _error_code(result):
        """A function to raise exceptions on errors, suitable
        for the 'restype' attribute on ctypes functions"""
        if result >= 0:
            return result
        if result == gnutls.E_NO_CERTIFICATE_FOUND:
            raise gnutls.CertificateSecurityError(code=result)
        raise gnutls.Error(code=result)

    def _retry_on_error(result, func, arguments):
        """A function to retry on some errors, suitable
        for the 'errcheck' attribute on ctypes functions"""
        while result < 0:
            if result not in (gnutls.E_INTERRUPTED, gnutls.E_AGAIN):
                return _error_code(result)
            result = func(*arguments)
        return result

    # Unless otherwise indicated, the function declarations below are
    # all from the gnutls/gnutls.h C header file.

    # Functions
    priority_set_direct = _library.gnutls_priority_set_direct
    priority_set_direct.argtypes = [session_t, ctypes.c_char_p,
                                    ctypes.POINTER(ctypes.c_char_p)]
    priority_set_direct.restype = _error_code

    init = _library.gnutls_init
    init.argtypes = [ctypes.POINTER(session_t), ctypes.c_int]
    init.restype = _error_code

    set_default_priority = _library.gnutls_set_default_priority
    set_default_priority.argtypes = [session_t]
    set_default_priority.restype = _error_code

    record_send = _library.gnutls_record_send
    record_send.argtypes = [session_t, ctypes.c_void_p,
                            ctypes.c_size_t]
    record_send.restype = ctypes.c_ssize_t
    record_send.errcheck = _retry_on_error

    certificate_allocate_credentials = (
        _library.gnutls_certificate_allocate_credentials)
    certificate_allocate_credentials.argtypes = [
        ctypes.POINTER(certificate_credentials_t)]
    certificate_allocate_credentials.restype = _error_code

    certificate_free_credentials = (
        _library.gnutls_certificate_free_credentials)
    certificate_free_credentials.argtypes = [
        certificate_credentials_t]
    certificate_free_credentials.restype = None

    handshake_set_private_extensions = (
        _library.gnutls_handshake_set_private_extensions)
    handshake_set_private_extensions.argtypes = [session_t,
                                                 ctypes.c_int]
    handshake_set_private_extensions.restype = None

    credentials_set = _library.gnutls_credentials_set
    credentials_set.argtypes = [session_t, credentials_type_t,
                                ctypes.c_void_p]
    credentials_set.restype = _error_code

    strerror = _library.gnutls_strerror
    strerror.argtypes = [ctypes.c_int]
    strerror.restype = ctypes.c_char_p

    certificate_type_get = _library.gnutls_certificate_type_get
    certificate_type_get.argtypes = [session_t]
    certificate_type_get.restype = _error_code

    certificate_get_peers = _library.gnutls_certificate_get_peers
    certificate_get_peers.argtypes = [session_t,
                                      ctypes.POINTER(ctypes.c_uint)]
    certificate_get_peers.restype = ctypes.POINTER(datum_t)

    global_set_log_level = _library.gnutls_global_set_log_level
    global_set_log_level.argtypes = [ctypes.c_int]
    global_set_log_level.restype = None

    global_set_log_function = _library.gnutls_global_set_log_function
    global_set_log_function.argtypes = [log_func]
    global_set_log_function.restype = None

    deinit = _library.gnutls_deinit
    deinit.argtypes = [session_t]
    deinit.restype = None

    handshake = _library.gnutls_handshake
    handshake.argtypes = [session_t]
    handshake.restype = _error_code
    handshake.errcheck = _retry_on_error

    transport_set_ptr = _library.gnutls_transport_set_ptr
    transport_set_ptr.argtypes = [session_t, transport_ptr_t]
    transport_set_ptr.restype = None

    bye = _library.gnutls_bye
    bye.argtypes = [session_t, close_request_t]
    bye.restype = _error_code
    bye.errcheck = _retry_on_error

    check_version = _library.gnutls_check_version
    check_version.argtypes = [ctypes.c_char_p]
    check_version.restype = ctypes.c_char_p

    # All the function declarations below are from gnutls/openpgp.h

    openpgp_crt_init = _library.gnutls_openpgp_crt_init
    openpgp_crt_init.argtypes = [ctypes.POINTER(openpgp_crt_t)]
    openpgp_crt_init.restype = _error_code

    openpgp_crt_import = _library.gnutls_openpgp_crt_import
    openpgp_crt_import.argtypes = [openpgp_crt_t,
                                   ctypes.POINTER(datum_t),
                                   openpgp_crt_fmt_t]
    openpgp_crt_import.restype = _error_code

    openpgp_crt_verify_self = _library.gnutls_openpgp_crt_verify_self
    openpgp_crt_verify_self.argtypes = [openpgp_crt_t, ctypes.c_uint,
                                        ctypes.POINTER(ctypes.c_uint)]
    openpgp_crt_verify_self.restype = _error_code

    openpgp_crt_deinit = _library.gnutls_openpgp_crt_deinit
    openpgp_crt_deinit.argtypes = [openpgp_crt_t]
    openpgp_crt_deinit.restype = None

    openpgp_crt_get_fingerprint = (
        _library.gnutls_openpgp_crt_get_fingerprint)
    openpgp_crt_get_fingerprint.argtypes = [openpgp_crt_t,
                                            ctypes.c_void_p,
                                            ctypes.POINTER(
                                                ctypes.c_size_t)]
    openpgp_crt_get_fingerprint.restype = _error_code

    # Remove non-public functions
    del _error_code, _retry_on_error
# Create the global "gnutls" object, simulating a module
gnutls = GnuTLS()

def call_pipe(connection,       # : multiprocessing.Connection
              func, *args, **kwargs):
    """This function is meant to be called by multiprocessing.Process
    
    This function runs func(*args, **kwargs), and writes the resulting
    return value on the provided multiprocessing.Connection.
    """
    connection.send(func(*args, **kwargs))
    connection.close()

class Client(object):
    """A representation of a client host served by this server.
    
    Attributes:
    approved:   bool(); 'None' if not yet approved/disapproved
    approval_delay: datetime.timedelta(); Time to wait for approval
    approval_duration: datetime.timedelta(); Duration of one approval
    checker:    subprocess.Popen(); a running checker process used
                                    to see if the client lives.
                                    'None' if no process is running.
    checker_callback_tag: a gobject event source tag, or None
    checker_command: string; External command which is run to check
                     if client lives.  %() expansions are done at
                     runtime with vars(self) as dict, so that for
                     instance %(name)s can be used in the command.
    checker_initiator_tag: a gobject event source tag, or None
    created:    datetime.datetime(); (UTC) object creation
    client_structure: Object describing what attributes a client has
                      and is used for storing the client at exit
    current_checker_command: string; current running checker_command
    disable_initiator_tag: a gobject event source tag, or None
    enabled:    bool()
    fingerprint: string (40 or 32 hexadecimal digits); used to
                 uniquely identify the client
    host:       string; available for use by the checker command
    interval:   datetime.timedelta(); How often to start a new checker
    last_approval_request: datetime.datetime(); (UTC) or None
    last_checked_ok: datetime.datetime(); (UTC) or None
    last_checker_status: integer between 0 and 255 reflecting exit
                         status of last checker. -1 reflects crashed
                         checker, -2 means no checker completed yet.
    last_checker_signal: The signal which killed the last checker, if
                         last_checker_status is -1
    last_enabled: datetime.datetime(); (UTC) or None
    name:       string; from the config file, used in log messages and
                        D-Bus identifiers
    secret:     bytestring; sent verbatim (over TLS) to client
    timeout:    datetime.timedelta(); How long from last_checked_ok
                                      until this client is disabled
    extended_timeout:   extra long timeout when secret has been sent
    runtime_expansions: Allowed attributes for runtime expansion.
    expires:    datetime.datetime(); time (UTC) when a client will be
                disabled, or None
    server_settings: The server_settings dict from main()
    """
    
    runtime_expansions = ("approval_delay", "approval_duration",
                          "created", "enabled", "expires",
                          "fingerprint", "host", "interval",
                          "last_approval_request", "last_checked_ok",
                          "last_enabled", "name", "timeout")
    client_defaults = {
        "timeout": "PT5M",
        "extended_timeout": "PT15M",
        "interval": "PT2M",
        "checker": "fping -q -- %%(host)s",
        "host": "",
        "approval_delay": "PT0S",
        "approval_duration": "PT1S",
        "approved_by_default": "True",
        "enabled": "True",
    }
    
    @staticmethod
    def config_parser(config):
        """Construct a new dict of client settings of this form:
        { client_name: {setting_name: value, ...}, ...}
        with exceptions for any special settings as defined above.
        NOTE: Must be a pure function. Must return the same result
        value given the same arguments.
        """
        settings = {}
        for client_name in config.sections():
            section = dict(config.items(client_name))
            client = settings[client_name] = {}
            
            client["host"] = section["host"]
            # Reformat values from string types to Python types
            client["approved_by_default"] = config.getboolean(
                client_name, "approved_by_default")
            client["enabled"] = config.getboolean(client_name,
                                                  "enabled")
            
            # Uppercase and remove spaces from fingerprint for later
            # comparison purposes with return value from the
            # fingerprint() function
            client["fingerprint"] = (section["fingerprint"].upper()
                                     .replace(" ", ""))
            if "secret" in section:
                client["secret"] = section["secret"].decode("base64")
            elif "secfile" in section:
                with open(os.path.expanduser(os.path.expandvars
                                             (section["secfile"])),
                          "rb") as secfile:
                    client["secret"] = secfile.read()
            else:
                raise TypeError("No secret or secfile for section {}"
                                .format(section))
            client["timeout"] = string_to_delta(section["timeout"])
            client["extended_timeout"] = string_to_delta(
                section["extended_timeout"])
            client["interval"] = string_to_delta(section["interval"])
            client["approval_delay"] = string_to_delta(
                section["approval_delay"])
            client["approval_duration"] = string_to_delta(
                section["approval_duration"])
            client["checker_command"] = section["checker"]
            client["last_approval_request"] = None
            client["last_checked_ok"] = None
            client["last_checker_status"] = -2
        
        return settings
    
    def __init__(self, settings, name = None, server_settings=None):
        self.name = name
        if server_settings is None:
            server_settings = {}
        self.server_settings = server_settings
        # adding all client settings
        for setting, value in settings.items():
            setattr(self, setting, value)
        
        if self.enabled:
            if not hasattr(self, "last_enabled"):
                self.last_enabled = datetime.datetime.utcnow()
            if not hasattr(self, "expires"):
                self.expires = (datetime.datetime.utcnow()
                                + self.timeout)
        else:
            self.last_enabled = None
            self.expires = None
        
        logger.debug("Creating client %r", self.name)
        logger.debug("  Fingerprint: %s", self.fingerprint)
        self.created = settings.get("created",
                                    datetime.datetime.utcnow())
        
        # attributes specific for this server instance
        self.checker = None
        self.checker_initiator_tag = None
        self.disable_initiator_tag = None
        self.checker_callback_tag = None
        self.current_checker_command = None
        self.approved = None
        self.approvals_pending = 0
        self.changedstate = multiprocessing_manager.Condition(
            multiprocessing_manager.Lock())
        self.client_structure = [attr
                                 for attr in self.__dict__.iterkeys()
                                 if not attr.startswith("_")]
        self.client_structure.append("client_structure")
        
        for name, t in inspect.getmembers(
                type(self), lambda obj: isinstance(obj, property)):
            if not name.startswith("_"):
                self.client_structure.append(name)
    
    # Send notice to process children that client state has changed
    def send_changedstate(self):
        with self.changedstate:
            self.changedstate.notify_all()
    
    def enable(self):
        """Start this client's checker and timeout hooks"""
        if getattr(self, "enabled", False):
            # Already enabled
            return
        self.expires = datetime.datetime.utcnow() + self.timeout
        self.enabled = True
        self.last_enabled = datetime.datetime.utcnow()
        self.init_checker()
        self.send_changedstate()
    
    def disable(self, quiet=True):
        """Disable this client."""
        if not getattr(self, "enabled", False):
            return False
        if not quiet:
            logger.info("Disabling client %s", self.name)
        if getattr(self, "disable_initiator_tag", None) is not None:
            gobject.source_remove(self.disable_initiator_tag)
            self.disable_initiator_tag = None
        self.expires = None
        if getattr(self, "checker_initiator_tag", None) is not None:
            gobject.source_remove(self.checker_initiator_tag)
            self.checker_initiator_tag = None
        self.stop_checker()
        self.enabled = False
        if not quiet:
            self.send_changedstate()
        # Do not run this again if called by a gobject.timeout_add
        return False
    
    def __del__(self):
        self.disable()
    
    def init_checker(self):
        # Schedule a new checker to be started an 'interval' from now,
        # and every interval from then on.
        if self.checker_initiator_tag is not None:
            gobject.source_remove(self.checker_initiator_tag)
        self.checker_initiator_tag = gobject.timeout_add(
            int(self.interval.total_seconds() * 1000),
            self.start_checker)
        # Schedule a disable() when 'timeout' has passed
        if self.disable_initiator_tag is not None:
            gobject.source_remove(self.disable_initiator_tag)
        self.disable_initiator_tag = gobject.timeout_add(
            int(self.timeout.total_seconds() * 1000), self.disable)
        # Also start a new checker *right now*.
        self.start_checker()
    
    def checker_callback(self, source, condition, connection,
                         command):
        """The checker has completed, so take appropriate actions."""
        self.checker_callback_tag = None
        self.checker = None
        # Read return code from connection (see call_pipe)
        returncode = connection.recv()
        connection.close()
        #returncode = 0
        
        if returncode >= 0:
            self.last_checker_status = returncode
            self.last_checker_signal = None
            if self.last_checker_status == 0:
                logger.info("Checker for %(name)s succeeded",
                            vars(self))
                self.checked_ok()
            else:
                logger.info("Checker for %(name)s failed", vars(self))
        else:
            self.last_checker_status = -1
            self.last_checker_signal = -returncode
            logger.warning("Checker for %(name)s crashed?",
                           vars(self))
        return False
    
    def checked_ok(self):
        """Assert that the client has been seen, alive and well."""
        self.last_checked_ok = datetime.datetime.utcnow()
        self.last_checker_status = 0
        self.last_checker_signal = None
        self.bump_timeout()
    
    def bump_timeout(self, timeout=None):
        """Bump up the timeout for this client."""
        if timeout is None:
            timeout = self.timeout
        if self.disable_initiator_tag is not None:
            gobject.source_remove(self.disable_initiator_tag)
            self.disable_initiator_tag = None
        if getattr(self, "enabled", False):
            self.disable_initiator_tag = gobject.timeout_add(
                int(timeout.total_seconds() * 1000), self.disable)
            self.expires = datetime.datetime.utcnow() + timeout
    
    def need_approval(self):
        self.last_approval_request = datetime.datetime.utcnow()
    
    def start_checker(self):
        """Start a new checker subprocess if one is not running.
        
        If a checker already exists, leave it running and do
        nothing."""
        # The reason for not killing a running checker is that if we
        # did that, and if a checker (for some reason) started running
        # slowly and taking more than 'interval' time, then the client
        # would inevitably timeout, since no checker would get a
        # chance to run to completion.  If we instead leave running
        # checkers alone, the checker would have to take more time
        # than 'timeout' for the client to be disabled, which is as it
        # should be.
        
        if self.checker is not None and not self.checker.is_alive():
            logger.warning("Checker was not alive; joining")
            self.checker.join()
            self.checker = None
        # Start a new checker if needed
        if self.checker is None:
            # Escape attributes for the shell
            escaped_attrs = {
                attr: re.escape(str(getattr(self, attr)))
                for attr in self.runtime_expansions }
            try:
                command = self.checker_command % escaped_attrs
            except TypeError as error:
                logger.error('Could not format string "%s"',
                             self.checker_command,
                             exc_info=error)
                return True     # Try again later
            self.current_checker_command = command
            logger.info("Starting checker %r for %s", command,
                        self.name)
            # We don't need to redirect stdout and stderr, since
            # in normal mode, that is already done by daemon(),
            # and in debug mode we don't want to.  (Stdin is
            # always replaced by /dev/null.)
            # The exception is when not debugging but nevertheless
            # running in the foreground; use the previously
            # created wnull.
            popen_args = { "close_fds": True,
                           "shell": True,
                           "cwd": "/" }
            if (not self.server_settings["debug"]
                and self.server_settings["foreground"]):
                popen_args.update({"stdout": wnull,
                                   "stderr": wnull })
            pipe = multiprocessing.Pipe(duplex = False)
            self.checker = multiprocessing.Process(
                target = call_pipe,
                args = (pipe[1], subprocess.call, command),
                kwargs = popen_args)
            self.checker.start()
            self.checker_callback_tag = gobject.io_add_watch(
                pipe[0].fileno(), gobject.IO_IN,
                self.checker_callback, pipe[0], command)
        # Re-run this periodically if run by gobject.timeout_add
        return True
    
    def stop_checker(self):
        """Force the checker process, if any, to stop."""
        if self.checker_callback_tag:
            gobject.source_remove(self.checker_callback_tag)
            self.checker_callback_tag = None
        if getattr(self, "checker", None) is None:
            return
        logger.debug("Stopping checker for %(name)s", vars(self))
        self.checker.terminate()
        self.checker = None


class ProxyClient(object):
    def __init__(self, child_pipe, fpr, address):
        self._pipe = child_pipe
        self._pipe.send(('init', fpr, address))
        if not self._pipe.recv():
            raise KeyError(fpr)
    
    def __getattribute__(self, name):
        if name == '_pipe':
            return super(ProxyClient, self).__getattribute__(name)
        self._pipe.send(('getattr', name))
        data = self._pipe.recv()
        if data[0] == 'data':
            return data[1]
        if data[0] == 'function':
            
            def func(*args, **kwargs):
                self._pipe.send(('funcall', name, args, kwargs))
                return self._pipe.recv()[1]
            
            return func
    
    def __setattr__(self, name, value):
        if name == '_pipe':
            return super(ProxyClient, self).__setattr__(name, value)
        self._pipe.send(('setattr', name, value))


class ClientHandler(socketserver.BaseRequestHandler, object):
    """A class to handle client connections.
    
    Instantiated once for each connection to handle it.
    Note: This will run in its own forked process."""
    
    def handle(self):
        with contextlib.closing(self.server.child_pipe) as child_pipe:
            logger.info("TCP connection from: %s",
                        str(self.client_address))
            logger.debug("Pipe FD: %d",
                         self.server.child_pipe.fileno())
            
            session = gnutls.ClientSession(self.request)
                       
            #priority = ':'.join(("NONE", "+VERS-TLS1.1",
            #                      "+AES-256-CBC", "+SHA1",
            #                      "+COMP-NULL", "+CTYPE-OPENPGP",
            #                      "+DHE-DSS"))
            # Use a fallback default, since this MUST be set.
            priority = self.server.gnutls_priority
            if priority is None:
                priority = "NORMAL"
            gnutls.priority_set_direct(
                session._c_object, priority, None)
            
            # Start communication using the Mandos protocol
            # Get protocol number
            line = self.request.makefile().readline()
            logger.debug("Protocol version: %r", line)
            try:
                if int(line.strip().split()[0]) > 1:
                    raise RuntimeError(line)
            except (ValueError, IndexError, RuntimeError) as error:
                logger.error("Unknown protocol version: %s", error)
                return
            
            # Start GnuTLS connection
            try:
                session.handshake()
            except gnutls.Error as error:
                logger.warning("Handshake failed: %s", error)
                # Do not run session.bye() here: the session is not
                # established.  Just abandon the request.
                return
            logger.debug("Handshake succeeded")
            
            approval_required = False
            try:
                try:
                    fpr = self.fingerprint(
                        self.peer_certificate(session))
                except (TypeError,
                        gnutls.Error) as error:
                    logger.warning("Bad certificate: %s", error)
                    return
                logger.debug("Fingerprint: %s", fpr)
                
                try:
                    client = ProxyClient(child_pipe, fpr,
                                         self.client_address)
                except KeyError:
                    return
                
                if client.approval_delay:
                    delay = client.approval_delay
                    client.approvals_pending += 1
                    approval_required = True
                
                while True:
                    if not client.enabled:
                        logger.info("Client %s is disabled",
                                    client.name)
                        return

                    if client.approved or not client.approval_delay:
                        # We are approved or approval is disabled
                        break
                    elif client.approved is None:
                        logger.info("Client %s needs approval",
                                    client.name)
                    else:
                        logger.warning("Client %s was not approved",
                                       client.name)
                        return

                    # wait until timeout or approved
                    time = datetime.datetime.now()
                    client.changedstate.acquire()
                    client.changedstate.wait(delay.total_seconds())
                    client.changedstate.release()
                    time2 = datetime.datetime.now()
                    if (time2 - time) >= delay:
                        if not client.approved_by_default:
                            logger.warning("Client %s timed out while"
                                           " waiting for approval",
                                           client.name)
                            return
                        else:
                            break
                    else:
                        delay -= time2 - time

                try:
                    session.send(client.secret)
                except gnutls.Error as error:
                    logger.warning("gnutls send failed",
                                   exc_info=error)
                    return

                logger.info("Sending secret to %s", client.name)
                # bump the timeout using extended_timeout
                client.bump_timeout(client.extended_timeout)

            finally:
                if approval_required:
                    client.approvals_pending -= 1
                try:
                    session.bye()
                except gnutls.Error as error:
                    logger.warning("GnuTLS bye failed",
                                   exc_info=error)
    
    @staticmethod
    def peer_certificate(session):
        "Return the peer's OpenPGP certificate as a bytestring"
        # If not an OpenPGP certificate...
        if (gnutls.certificate_type_get(session._c_object)
            != gnutls.CRT_OPENPGP):
            # ...return invalid data
            return b""
        list_size = ctypes.c_uint(1)
        cert_list = (gnutls.certificate_get_peers
                     (session._c_object, ctypes.byref(list_size)))
        if not bool(cert_list) and list_size.value != 0:
            raise gnutls.Error("error getting peer certificate")
        if list_size.value == 0:
            return None
        cert = cert_list[0]
        return ctypes.string_at(cert.data, cert.size)

    @staticmethod
    def fingerprint(openpgp):
        "Convert an OpenPGP bytestring to a hexdigit fingerprint"
        # New GnuTLS "datum" with the OpenPGP public key
        datum = gnutls.datum_t(
            ctypes.cast(ctypes.c_char_p(openpgp),
                        ctypes.POINTER(ctypes.c_ubyte)),
            ctypes.c_uint(len(openpgp)))
        # New empty GnuTLS certificate
        crt = gnutls.openpgp_crt_t()
        gnutls.openpgp_crt_init(ctypes.byref(crt))
        # Import the OpenPGP public key into the certificate
        gnutls.openpgp_crt_import(crt, ctypes.byref(datum),
                                  gnutls.OPENPGP_FMT_RAW)
        # Verify the self signature in the key
        crtverify = ctypes.c_uint()
        gnutls.openpgp_crt_verify_self(crt, 0,
                                       ctypes.byref(crtverify))
        if crtverify.value != 0:
            gnutls.openpgp_crt_deinit(crt)
            raise gnutls.CertificateSecurityError(code
                                                  =crtverify.value)
        # New buffer for the fingerprint
        buf = ctypes.create_string_buffer(20)
        buf_len = ctypes.c_size_t()
        # Get the fingerprint from the certificate into the buffer
        gnutls.openpgp_crt_get_fingerprint(crt, ctypes.byref(buf),
                                           ctypes.byref(buf_len))
        # Deinit the certificate
        gnutls.openpgp_crt_deinit(crt)
        # Convert the buffer to a Python bytestring
        fpr = ctypes.string_at(buf, buf_len.value)
        # Convert the bytestring to hexadecimal notation
        hex_fpr = binascii.hexlify(fpr).upper()
        return hex_fpr

class Reader(object):
    def handle_read(_sock):
        logger.info(_sock)
        return
    
class MultiprocessingMixIn(object):
    """Like socketserver.ThreadingMixIn, but with multiprocessing"""
    
    def sub_process_main(self, request, address):
        try:
            self.finish_request(request, address)
        except Exception:
            self.handle_error(request, address)
        self.close_request(request)
    
    def process_request(self, request, address):
        """Start a new process to process the request."""
        proc = multiprocessing.Process(target = self.sub_process_main,
                                       args = (request, address))
        proc.start()
        return proc


class MultiprocessingMixInWithPipe(MultiprocessingMixIn, object):
    """ adds a pipe to the MixIn """
    
    def process_request(self, request, client_address):
        """Overrides and wraps the original process_request().
        
        This function creates a new pipe in self.pipe
        """
        parent_pipe, self.child_pipe = multiprocessing.Pipe()
        
        proc = MultiprocessingMixIn.process_request(self, request,
                                                    client_address)
        self.child_pipe.close()
        self.add_pipe(parent_pipe, proc)
    
    def add_pipe(self, parent_pipe, proc):
        """Dummy function; override as necessary"""
        raise NotImplementedError()


class IPv6_TCPServer(MultiprocessingMixInWithPipe,
                     socketserver.TCPServer, object):
    """IPv6-capable TCP server.  Accepts 'None' as address and/or port
    
    Attributes:
        enabled:        Boolean; whether this server is activated yet
        interface:      None or a network interface name (string)
        use_ipv6:       Boolean; to use IPv6 or not
    """
    
    def __init__(self, server_address, RequestHandlerClass,
                 interface=None,
                 use_ipv6=True,
                 socketfd=None):
        """If socketfd is set, use that file descriptor instead of
        creating a new one with socket.socket().
        """
        self.interface = interface
        if use_ipv6:
            self.address_family = socket.AF_INET6
        if socketfd is not None:
            # Save the file descriptor
            self.socketfd = socketfd
            # Save the original socket.socket() function
            self.socket_socket = socket.socket
            # To implement --socket, we monkey patch socket.socket.
            # 
            # (When socketserver.TCPServer is a new-style class, we
            # could make self.socket into a property instead of monkey
            # patching socket.socket.)
            # 
            # Create a one-time-only replacement for socket.socket()
            @functools.wraps(socket.socket)
            def socket_wrapper(*args, **kwargs):
                # Restore original function so subsequent calls are
                # not affected.
                socket.socket = self.socket_socket
                del self.socket_socket
                # This time only, return a new socket object from the
                # saved file descriptor.
                return socket.fromfd(self.socketfd, *args, **kwargs)
            # Replace socket.socket() function with wrapper
            socket.socket = socket_wrapper
        # The socketserver.TCPServer.__init__ will call
        # socket.socket(), which might be our replacement,
        # socket_wrapper(), if socketfd was set.
        socketserver.TCPServer.__init__(self, server_address,
                                        RequestHandlerClass)
    
    def server_bind(self):
        """This overrides the normal server_bind() function
        to bind to an interface if one was specified, and also NOT to
        bind to an address or port if they were not specified."""
        if self.interface is not None:
            if SO_BINDTODEVICE is None:
                logger.error("SO_BINDTODEVICE does not exist;"
                             " cannot bind to interface %s",
                             self.interface)
            else:
                try:
                    self.socket.setsockopt(
                        socket.SOL_SOCKET, SO_BINDTODEVICE,
                        (self.interface + "\0").encode("utf-8"))
                except socket.error as error:
                    if error.errno == errno.EPERM:
                        logger.error("No permission to bind to"
                                     " interface %s", self.interface)
                    elif error.errno == errno.ENOPROTOOPT:
                        logger.error("SO_BINDTODEVICE not available;"
                                     " cannot bind to interface %s",
                                     self.interface)
                    elif error.errno == errno.ENODEV:
                        logger.error("Interface %s does not exist,"
                                     " cannot bind", self.interface)
                    else:
                        raise
        # Only bind(2) the socket if we really need to.
        if self.server_address[0] or self.server_address[1]:
            if not self.server_address[0]:
                if self.address_family == socket.AF_INET6:
                    any_address = "::" # in6addr_any
                else:
                    any_address = "0.0.0.0" # INADDR_ANY
                self.server_address = (any_address,
                                       self.server_address[1])
            elif not self.server_address[1]:
                self.server_address = (self.server_address[0], 0)
#                 if self.interface:
#                     self.server_address = (self.server_address[0],
#                                            0, # port
#                                            0, # flowinfo
#                                            if_nametoindex
#                                            (self.interface))
            return socketserver.TCPServer.server_bind(self)


class MandosServer(IPv6_TCPServer):
    """Mandos server.
    
    Attributes:
        clients:        set of Client objects
        gnutls_priority GnuTLS priority string
    
    Assumes a gobject.MainLoop event loop.
    """
    
    def __init__(self, server_address, RequestHandlerClass,
                 interface=None,
                 use_ipv6=True,
                 clients=None,
                 gnutls_priority=None,
                 socketfd=None):
        self.enabled = False
        self.clients = clients
        if self.clients is None:
            self.clients = {}
        self.gnutls_priority = gnutls_priority
        IPv6_TCPServer.__init__(self, server_address,
                                RequestHandlerClass,
                                interface = interface,
                                use_ipv6 = use_ipv6,
                                socketfd = socketfd)
    
    def server_activate(self):
        if self.enabled:
            return socketserver.TCPServer.server_activate(self)
    
    def enable(self):
        self.enabled = True
    
    def add_pipe(self, parent_pipe, proc):
        # Call "handle_ipc" for both data and EOF events
        gobject.io_add_watch(
            parent_pipe.fileno(),
            gobject.IO_IN | gobject.IO_HUP,
            functools.partial(self.handle_ipc,
                              parent_pipe = parent_pipe,
                              proc = proc))
    
    def handle_ipc(self, source, condition,
                   parent_pipe=None,
                   proc = None,
                   client_object=None):
        # error, or the other end of multiprocessing.Pipe has closed
        if condition & (gobject.IO_ERR | gobject.IO_HUP):
            # Wait for other process to exit
            proc.join()
            return False
        
        # Read a request from the child
        request = parent_pipe.recv()
        command = request[0]
        
        if command == 'init':
            fpr = request[1]
            address = request[2]
            
            for c in self.clients.itervalues():
                if c.fingerprint == fpr:
                    client = c
                    break
            else:
                logger.info("Client not found for fingerprint: %s, ad"
                            "dress: %s", fpr, address)
                parent_pipe.send(False)
                return False
            
            gobject.io_add_watch(
                parent_pipe.fileno(),
                gobject.IO_IN | gobject.IO_HUP,
                functools.partial(self.handle_ipc,
                                  parent_pipe = parent_pipe,
                                  proc = proc,
                                  client_object = client))
            parent_pipe.send(True)
            # remove the old hook in favor of the new above hook on
            # same fileno
            return False
        if command == 'funcall':
            funcname = request[1]
            args = request[2]
            kwargs = request[3]
            
            parent_pipe.send(('data', getattr(client_object,
                                              funcname)(*args,
                                                        **kwargs)))
        
        if command == 'getattr':
            attrname = request[1]
            if isinstance(client_object.__getattribute__(attrname),
                          collections.Callable):
                parent_pipe.send(('function', ))
            else:
                parent_pipe.send((
                    'data', client_object.__getattribute__(attrname)))
        
        if command == 'setattr':
            attrname = request[1]
            value = request[2]
            setattr(client_object, attrname, value)
        
        return True


def rfc3339_duration_to_delta(duration):
    """Parse an RFC 3339 "duration" and return a datetime.timedelta
    
    >>> rfc3339_duration_to_delta("P7D")
    datetime.timedelta(7)
    >>> rfc3339_duration_to_delta("PT60S")
    datetime.timedelta(0, 60)
    >>> rfc3339_duration_to_delta("PT60M")
    datetime.timedelta(0, 3600)
    >>> rfc3339_duration_to_delta("PT24H")
    datetime.timedelta(1)
    >>> rfc3339_duration_to_delta("P1W")
    datetime.timedelta(7)
    >>> rfc3339_duration_to_delta("PT5M30S")
    datetime.timedelta(0, 330)
    >>> rfc3339_duration_to_delta("P1DT3M20S")
    datetime.timedelta(1, 200)
    """
    
    # Parsing an RFC 3339 duration with regular expressions is not
    # possible - there would have to be multiple places for the same
    # values, like seconds.  The current code, while more esoteric, is
    # cleaner without depending on a parsing library.  If Python had a
    # built-in library for parsing we would use it, but we'd like to
    # avoid excessive use of external libraries.
    
    # New type for defining tokens, syntax, and semantics all-in-one
    Token = collections.namedtuple("Token", (
        "regexp",  # To match token; if "value" is not None, must have
                   # a "group" containing digits
        "value",   # datetime.timedelta or None
        "followers"))           # Tokens valid after this token
    # RFC 3339 "duration" tokens, syntax, and semantics; taken from
    # the "duration" ABNF definition in RFC 3339, Appendix A.
    token_end = Token(re.compile(r"$"), None, frozenset())
    token_second = Token(re.compile(r"(\d+)S"),
                         datetime.timedelta(seconds=1),
                         frozenset((token_end, )))
    token_minute = Token(re.compile(r"(\d+)M"),
                         datetime.timedelta(minutes=1),
                         frozenset((token_second, token_end)))
    token_hour = Token(re.compile(r"(\d+)H"),
                       datetime.timedelta(hours=1),
                       frozenset((token_minute, token_end)))
    token_time = Token(re.compile(r"T"),
                       None,
                       frozenset((token_hour, token_minute,
                                  token_second)))
    token_day = Token(re.compile(r"(\d+)D"),
                      datetime.timedelta(days=1),
                      frozenset((token_time, token_end)))
    token_month = Token(re.compile(r"(\d+)M"),
                        datetime.timedelta(weeks=4),
                        frozenset((token_day, token_end)))
    token_year = Token(re.compile(r"(\d+)Y"),
                       datetime.timedelta(weeks=52),
                       frozenset((token_month, token_end)))
    token_week = Token(re.compile(r"(\d+)W"),
                       datetime.timedelta(weeks=1),
                       frozenset((token_end, )))
    token_duration = Token(re.compile(r"P"), None,
                           frozenset((token_year, token_month,
                                      token_day, token_time,
                                      token_week)))
    # Define starting values
    value = datetime.timedelta() # Value so far
    found_token = None
    followers = frozenset((token_duration, )) # Following valid tokens
    s = duration                # String left to parse
    # Loop until end token is found
    while found_token is not token_end:
        # Search for any currently valid tokens
        for token in followers:
            match = token.regexp.match(s)
            if match is not None:
                # Token found
                if token.value is not None:
                    # Value found, parse digits
                    factor = int(match.group(1), 10)
                    # Add to value so far
                    value += factor * token.value
                # Strip token from string
                s = token.regexp.sub("", s, 1)
                # Go to found token
                found_token = token
                # Set valid next tokens
                followers = found_token.followers
                break
        else:
            # No currently valid tokens were found
            raise ValueError("Invalid RFC 3339 duration: {!r}"
                             .format(duration))
    # End token found
    return value


def string_to_delta(interval):
    """Parse a string and return a datetime.timedelta
    
    >>> string_to_delta('7d')
    datetime.timedelta(7)
    >>> string_to_delta('60s')
    datetime.timedelta(0, 60)
    >>> string_to_delta('60m')
    datetime.timedelta(0, 3600)
    >>> string_to_delta('24h')
    datetime.timedelta(1)
    >>> string_to_delta('1w')
    datetime.timedelta(7)
    >>> string_to_delta('5m 30s')
    datetime.timedelta(0, 330)
    """
    
    try:
        return rfc3339_duration_to_delta(interval)
    except ValueError:
        pass
    
    timevalue = datetime.timedelta(0)
    for s in interval.split():
        try:
            suffix = s[-1]
            value = int(s[:-1])
            if suffix == "d":
                delta = datetime.timedelta(value)
            elif suffix == "s":
                delta = datetime.timedelta(0, value)
            elif suffix == "m":
                delta = datetime.timedelta(0, 0, 0, 0, value)
            elif suffix == "h":
                delta = datetime.timedelta(0, 0, 0, 0, 0, value)
            elif suffix == "w":
                delta = datetime.timedelta(0, 0, 0, 0, 0, 0, value)
            else:
                raise ValueError("Unknown suffix {!r}".format(suffix))
        except IndexError as e:
            raise ValueError(*(e.args))
        timevalue += delta
    return timevalue


def daemon(nochdir = False, noclose = False):
    """See daemon(3).  Standard BSD Unix function.
    
    This should really exist as os.daemon, but it doesn't (yet)."""
    if os.fork():
        sys.exit()
    os.setsid()
    if not nochdir:
        os.chdir("/")
    if os.fork():
        sys.exit()
    if not noclose:
        # Close all standard open file descriptors
        null = os.open(os.devnull, os.O_NOCTTY | os.O_RDWR)
        if not stat.S_ISCHR(os.fstat(null).st_mode):
            raise OSError(errno.ENODEV,
                          "{} not a character device"
                          .format(os.devnull))
        os.dup2(null, sys.stdin.fileno())
        os.dup2(null, sys.stdout.fileno())
        os.dup2(null, sys.stderr.fileno())
        if null > 2:
            os.close(null)


def main():
    
    ##################################################################
    # Parsing of options, both command line and config file
    
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--version", action="version",
                        version = "%(prog)s {}".format(version),
                        help="show version number and exit")
    parser.add_argument("-i", "--interface", metavar="IF",
                        help="Bind to interface IF")
    parser.add_argument("-a", "--address",
                        help="Address to listen for requests on")
    parser.add_argument("-p", "--port", type=int,
                        help="Port number to receive requests on")
    parser.add_argument("--check", action="store_true",
                        help="Run self-test")
    parser.add_argument("--debug", action="store_true",
                        help="Debug mode; run in foreground and log"
                        " to terminal", default=None)
    parser.add_argument("--debuglevel", metavar="LEVEL",
                        help="Debug level for stdout output")
    parser.add_argument("--priority", help="GnuTLS"
                        " priority string (see GnuTLS documentation)")
    parser.add_argument("--servicename",
                        metavar="NAME", help="Zeroconf service name")
    parser.add_argument("--configdir",
                        default="/etc/mandos", metavar="DIR",
                        help="Directory to search for configuration"
                        " files")
    parser.add_argument("--no-ipv6", action="store_false",
                        dest="use_ipv6", help="Do not use IPv6",
                        default=None)
    parser.add_argument("--no-restore", action="store_false",
                        dest="restore", help="Do not restore stored"
                        " state", default=None)
    parser.add_argument("--socket", type=int,
                        help="Specify a file descriptor to a network"
                        " socket to use instead of creating one")
    parser.add_argument("--statedir", metavar="DIR",
                        help="Directory to save/restore state in")
    parser.add_argument("--foreground", action="store_true",
                        help="Run in foreground", default=None)
    parser.add_argument("--no-zeroconf", action="store_false",
                        dest="zeroconf", help="Do not use Zeroconf",
                        default=None)
    
    options = parser.parse_args()
    
    if options.check:
        import doctest
        fail_count, test_count = doctest.testmod()
        sys.exit(os.EX_OK if fail_count == 0 else 1)
    
    # Default values for config file for server-global settings
    server_defaults = { "interface": "",
                        "address": "",
                        "port": "",
                        "debug": "False",
                        "priority":
                        "SECURE256:!CTYPE-X.509:+CTYPE-OPENPGP:!RSA"
                        ":+SIGN-DSA-SHA256",
                        "servicename": "Mandos",
                        "use_ipv6": "True",
                        "debuglevel": "",
                        "restore": "True",
                        "socket": "",
                        "statedir": "/var/lib/mandos",
                        "foreground": "False",
                        "zeroconf": "True",
                    }
    
    # Parse config file for server-global settings
    server_config = configparser.SafeConfigParser(server_defaults)
    del server_defaults
    server_config.read(os.path.join(options.configdir, "mandos.conf"))
    # Convert the SafeConfigParser object to a dict
    server_settings = server_config.defaults()
    # Use the appropriate methods on the non-string config options
    for option in ("debug", "use_ipv6", "foreground"):
        server_settings[option] = server_config.getboolean("DEFAULT",
                                                           option)
    if server_settings["port"]:
        server_settings["port"] = server_config.getint("DEFAULT",
                                                       "port")
    if server_settings["socket"]:
        server_settings["socket"] = server_config.getint("DEFAULT",
                                                         "socket")
        # Later, stdin will, and stdout and stderr might, be dup'ed
        # over with an opened os.devnull.  But we don't want this to
        # happen with a supplied network socket.
        if 0 <= server_settings["socket"] <= 2:
            server_settings["socket"] = os.dup(server_settings
                                               ["socket"])
    del server_config
    
    # Override the settings from the config file with command line
    # options, if set.
    for option in ("interface", "address", "port", "debug",
                   "priority", "servicename", "configdir", 
                   "use_ipv6", "debuglevel", "restore", "statedir",
                   "socket", "foreground", "zeroconf"):
        value = getattr(options, option)
        if value is not None:
            server_settings[option] = value
    del options
    # Force all strings to be unicode
    for option in server_settings.keys():
        if isinstance(server_settings[option], bytes):
            server_settings[option] = (server_settings[option]
                                       .decode("utf-8"))
    # Force all boolean options to be boolean
    for option in ("debug", "use_ipv6", "restore",
                   "foreground", "zeroconf"):
        server_settings[option] = bool(server_settings[option])

    # Debug implies foreground
    if server_settings["debug"]:
        server_settings["foreground"] = True
    # Now we have our good server settings in "server_settings"
    
    ##################################################################
    
    if (not server_settings["zeroconf"]
        and not (server_settings["port"]
                 or server_settings["socket"] != "")):
        parser.error("Needs port or socket to work without Zeroconf")
    
    # For convenience
    debug = server_settings["debug"]
    debuglevel = server_settings["debuglevel"]
    use_ipv6 = server_settings["use_ipv6"]
    stored_state_path = os.path.join(server_settings["statedir"],
                                     stored_state_file)
    foreground = server_settings["foreground"]
    
    usezeroconf = server_settings["zeroconf"]
    if debug:
        initlogger(debug, logging.DEBUG)
    else:
        if not debuglevel:
            initlogger(debug)
        else:
            level = getattr(logging, debuglevel.upper())
            initlogger(debug, level)
    
    if server_settings["servicename"] != "Mandos":
        syslogger.setFormatter(
            logging.Formatter('Mandos ({}) [%(process)d]:'
                              ' %(levelname)s: %(message)s'.format(
                                  server_settings["servicename"])))
    
    # Parse config file with clients
    client_config = configparser.SafeConfigParser(Client
                                                  .client_defaults)
    
    client_config.read(os.path.join(server_settings["configdir"],
                                    "clients.conf"))
    
    socketfd = None
    if server_settings["socket"] != "":
        socketfd = server_settings["socket"]
    tcp_server = MandosServer(
        (server_settings["address"], server_settings["port"]),
        ClientHandler,
        interface=None,
        use_ipv6=use_ipv6,
        gnutls_priority=server_settings["priority"],
        socketfd=socketfd)
    if not foreground:
        pidfilename = "/run/mandos.pid"
        if not os.path.isdir("/run/."):
            pidfilename = "/var/run/mandos.pid"
        pidfile = None
        try:
            pidfile = codecs.open(pidfilename, "w", encoding="utf-8")
        except IOError as e:
            logger.error("Could not open file %r", pidfilename,
                         exc_info=e)
    
    for name in ("_mandos", "mandos", "nobody"):
        try:
            uid = pwd.getpwnam(name).pw_uid
            gid = pwd.getpwnam(name).pw_gid
            break
        except KeyError:
            continue
    else:
        uid = 65534
        gid = 65534
    try:
        os.setgid(gid)
        os.setuid(uid)
    except OSError as error:
        if error.errno != errno.EPERM:
            raise
    
    if debug:
        # Enable all possible GnuTLS debugging

        # "Use a log level over 10 to enable all debugging options."
        # - GnuTLS manual
        gnutls.global_set_log_level(11)

        @gnutls.log_func
        def debug_gnutls(level, string):
            logger.debug("GnuTLS: %s", string[:-1])

        gnutls.global_set_log_function(debug_gnutls)

        # Redirect stdin so all checkers get /dev/null
        null = os.open(os.devnull, os.O_NOCTTY | os.O_RDWR)
        os.dup2(null, sys.stdin.fileno())
        if null > 2:
            os.close(null)
    
    # Need to fork before connecting to D-Bus
    if not foreground:
        # Close all input and output, do double fork, etc.
        daemon()
    
    # multiprocessing will use threads, so before we use gobject we
    # need to inform gobject that threads will be used.
    gobject.threads_init()
    
    global main_loop
    main_loop = gobject.MainLoop()
    if usezeroconf:
        service = Zeroconf()
    
    global multiprocessing_manager
    multiprocessing_manager = multiprocessing.Manager()
    
    client_class = Client
    
    client_settings = Client.config_parser(client_config)
    old_client_settings = {}
    clients_data = {}
    
    # This is used to redirect stdout and stderr for checker processes
    global wnull
    wnull = open(os.devnull, "w") # A writable /dev/null
    # Only used if server is running in foreground but not in debug
    # mode
    if debug or not foreground:
        wnull.close()
    
    # Get client data and settings from last running state.
    if server_settings["restore"]:
        try:
            with open(stored_state_path, "rb") as stored_state:
                clients_data, old_client_settings = pickle.load(
                    stored_state)
            os.remove(stored_state_path)
        except IOError as e:
            if e.errno == errno.ENOENT:
                logger.warning("Could not load persistent state:"
                               " {}".format(os.strerror(e.errno)))
            else:
                logger.critical("Could not load persistent state:",
                                exc_info=e)
                raise
        except EOFError as e:
            logger.warning("Could not load persistent state: "
                           "EOFError:",
                           exc_info=e)
    
    with PGPEngine() as pgp:
        for client_name, client in clients_data.items():
            # Skip removed clients
            if client_name not in client_settings:
                continue
            
            # Decide which value to use after restoring saved state.
            # We have three different values: Old config file,
            # new config file, and saved state.
            # New config value takes precedence if it differs from old
            # config value, otherwise use saved state.
            for name, value in client_settings[client_name].items():
                try:
                    # For each value in new config, check if it
                    # differs from the old config value (Except for
                    # the "secret" attribute)
                    if (name != "secret"
                        and (value !=
                             old_client_settings[client_name][name])):
                        client[name] = value
                except KeyError:
                    pass
            
            # Clients who has passed its expire date can still be
            # enabled if its last checker was successful.  A Client
            # whose checker succeeded before we stored its state is
            # assumed to have successfully run all checkers during
            # downtime.
            if client["enabled"]:
                if datetime.datetime.utcnow() >= client["expires"]:
                    if not client["last_checked_ok"]:
                        logger.warning(
                            "disabling client {} - Client never "
                            "performed a successful checker".format(
                                client_name))
                        client["enabled"] = False
                    elif client["last_checker_status"] != 0:
                        logger.warning(
                            "disabling client {} - Client last"
                            " checker failed with error code"
                            " {}".format(
                                client_name,
                                client["last_checker_status"]))
                        client["enabled"] = False
                    else:
                        client["expires"] = (
                            datetime.datetime.utcnow()
                            + client["timeout"])
                        logger.debug("Last checker succeeded,"
                                     " keeping {} enabled".format(
                                         client_name))
            try:
                client["secret"] = pgp.decrypt(
                    client["encrypted_secret"],
                    client_settings[client_name]["secret"])
            except PGPError:
                # If decryption fails, we use secret from new settings
                logger.debug("Failed to decrypt {} old secret".format(
                    client_name))
                client["secret"] = (client_settings[client_name]
                                    ["secret"])
    
    # Add/remove clients based on new changes made to config
    for client_name in (set(old_client_settings)
                        - set(client_settings)):
        del clients_data[client_name]
    for client_name in (set(client_settings)
                        - set(old_client_settings)):
        clients_data[client_name] = client_settings[client_name]
    
    # Create all client objects
    for client_name, client in clients_data.items():
        tcp_server.clients[client_name] = client_class(
            name = client_name,
            settings = client,
            server_settings = server_settings)
    
    if not tcp_server.clients:
        logger.warning("No clients defined")
    
    if not foreground:
        if pidfile is not None:
            pid = os.getpid()
            try:
                with pidfile:
                    print(pid, file=pidfile)
            except IOError:
                logger.error("Could not write to file %r with PID %d",
                             pidfilename, pid)
        del pidfile
        del pidfilename
    
    signal.signal(signal.SIGHUP, lambda signum, frame: sys.exit())
    signal.signal(signal.SIGTERM, lambda signum, frame: sys.exit())
        
    def cleanup():
        "Cleanup function; run on exit"
        if usezeroconf:
            service.unregister_service(serviceInfo)
            service.close()
        
        multiprocessing.active_children()
        wnull.close()
        if not (tcp_server.clients or client_settings):
            return
        
        # Store client before exiting. Secrets are encrypted with key
        # based on what config file has. If config file is
        # removed/edited, old secret will thus be unrecovable.
        clients = {}
        with PGPEngine() as pgp:
            for client in tcp_server.clients.itervalues():
                key = client_settings[client.name]["secret"]
                client.encrypted_secret = pgp.encrypt(client.secret,
                                                      key)
                client_dict = {}
                
                # A list of attributes that can not be pickled
                # + secret.
                exclude = { "bus", "changedstate", "secret",
                            "checker", "server_settings" }
                
                client_dict["encrypted_secret"] = (client
                                                   .encrypted_secret)
                for attr in client.client_structure:
                    if attr not in exclude:
                        client_dict[attr] = getattr(client, attr)
                
                clients[client.name] = client_dict
                del client_settings[client.name]["secret"]
        
        try:
            with tempfile.NamedTemporaryFile(
                    mode='wb',
                    suffix=".pickle",
                    prefix='clients-',
                    dir=os.path.dirname(stored_state_path),
                    delete=False) as stored_state:
                pickle.dump((clients, client_settings), stored_state)
                tempname = stored_state.name
            os.rename(tempname, stored_state_path)
        except (IOError, OSError) as e:
            if not debug:
                try:
                    os.remove(tempname)
                except NameError:
                    pass
            if e.errno in (errno.ENOENT, errno.EACCES, errno.EEXIST):
                logger.warning("Could not save persistent state: {}"
                               .format(os.strerror(e.errno)))
            else:
                logger.warning("Could not save persistent state:",
                               exc_info=e)
                raise
        
        # Delete all clients, and settings from config
        while tcp_server.clients:
            name, client = tcp_server.clients.popitem()
            
            # Don't signal the disabling
            client.disable(quiet=True)
            # Emit D-Bus signal for removal
        client_settings.clear()
    
    atexit.register(cleanup)
    
    for client in tcp_server.clients.itervalues():
        # Need to initiate checking of clients
        if client.enabled:
            client.init_checker()
    
    tcp_server.enable()
    tcp_server.server_activate()
    
    # Find out what port we got
    sockInfo = tcp_server.socket.getsockname()
    family = socket.AF_INET
    myIP = get_lan_ip()
    if usezeroconf:
        logger.info("Registering service");
        serviceInfo = ServiceInfo("_mandos._tcp.local.",
                                  server_settings["servicename"]+"._mandos._tcp.local.",
                                  socket.inet_pton(family, myIP),
                                  tcp_server.socket.getsockname()[1],
                                  0,
                                  0,
                                  { 'Version': version }
                                  )
    if use_ipv6:
        logger.info("Now listening on address %r, port %d,"
                    " flowinfo %d, scope_id %d",
                    myIP,
                    sockInfo[1],
                    sockInfo[2],
                    sockInfo[3]
                    )
    else:                       # IPv4
        logger.info("Now listening on address %r, port %d",
                    myIP,
                    sockInfo[1]
                    )
    
    #service.interface = tcp_server.socket.getsockname()[3]

    try:
        if usezeroconf:
            service.register_service(serviceInfo)
        gobject.io_add_watch(tcp_server.fileno(), gobject.IO_IN,
                            lambda *args, **kwargs:
                            (tcp_server.handle_request
                            (*args[2:], **kwargs) or True))
        
        logger.debug("Starting main loop")
        main_loop.run()
    except Error as error:
        logger.critical("Error", exc_info=error)
        cleanup()
        sys.exit(1)
    except KeyboardInterrupt:
        if debug:
            print("", file=sys.stderr)
        logger.debug("Server received KeyboardInterrupt")
    logger.debug("Server exiting")
    # Must run before the D-Bus bus name gets deregistered
    cleanup()

def get_lan_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 53))
    ip = s.getsockname()[0]
    s.close()
    return ip
    
if __name__ == '__main__':
    main()
